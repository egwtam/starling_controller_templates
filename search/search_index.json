{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Starling Tutorial \u00b6 Starling Tutorial Introduction What is Starling What Will I learn In This Tutorial The Tutorial Task Scenario How To Use This Tutorial Contents Introduction \u00b6 What is Starling \u00b6 Starling is an end to end, modular, containerised UAV infrastucture designed to facilitate the local development, testing and deployment of Single and Multi-UAV systems from simulation to the Bristol Robotics Lab Flight Arena (and hopefully beyond). It will hopefully allow for a more approachable development workflow to enable more researchers to fly UAVs in a safe, reproducable and controllable manner. This tutorial is intended to demonstrate how to use Starling to develop and deploy a multi-uav controller. What Will I learn In This Tutorial \u00b6 In this tutorial you will The Tutorial Task Scenario \u00b6 You have been asked to prototype a particular scene within a drone display! In this scene a number of drones take off and automatically fly to starting points equidistant around a circle of a given radius. They then start circling around the edge of the circle attempting to stay equidistant to their neighbours. It is determined that the vehicles have not been well tuned and can end up lagging, therefore a centralised server monitors all the vehicles and notifies them if they are lagging behind. How To Use This Tutorial \u00b6 This tutorial Contents \u00b6","title":"Starling Tutorial"},{"location":"#starling-tutorial","text":"Starling Tutorial Introduction What is Starling What Will I learn In This Tutorial The Tutorial Task Scenario How To Use This Tutorial Contents","title":"Starling Tutorial"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#what-is-starling","text":"Starling is an end to end, modular, containerised UAV infrastucture designed to facilitate the local development, testing and deployment of Single and Multi-UAV systems from simulation to the Bristol Robotics Lab Flight Arena (and hopefully beyond). It will hopefully allow for a more approachable development workflow to enable more researchers to fly UAVs in a safe, reproducable and controllable manner. This tutorial is intended to demonstrate how to use Starling to develop and deploy a multi-uav controller.","title":"What is Starling"},{"location":"#what-will-i-learn-in-this-tutorial","text":"In this tutorial you will","title":"What Will I learn In This Tutorial"},{"location":"#the-tutorial-task-scenario","text":"You have been asked to prototype a particular scene within a drone display! In this scene a number of drones take off and automatically fly to starting points equidistant around a circle of a given radius. They then start circling around the edge of the circle attempting to stay equidistant to their neighbours. It is determined that the vehicles have not been well tuned and can end up lagging, therefore a centralised server monitors all the vehicles and notifies them if they are lagging behind.","title":"The Tutorial Task Scenario"},{"location":"#how-to-use-this-tutorial","text":"This tutorial","title":"How To Use This Tutorial"},{"location":"#contents","text":"","title":"Contents"},{"location":"brl/","text":"Bristol Robotics Laboratory Flying Arena \u00b6","title":"10. Bristol Robotics Laboratory Flying Arena"},{"location":"brl/#bristol-robotics-laboratory-flying-arena","text":"","title":"Bristol Robotics Laboratory Flying Arena"},{"location":"brl_flight/","text":"Flying your controllers in the Flying Arena \u00b6","title":"11. Flying your controllers in the Flying Arena"},{"location":"brl_flight/#flying-your-controllers-in-the-flying-arena","text":"","title":"Flying your controllers in the Flying Arena"},{"location":"cpp_example_dev/","text":"Developing the example controller with ROS2 in CPP \u00b6","title":"6. Developing the example controller with ROS2 in CPP"},{"location":"cpp_example_dev/#developing-the-example-controller-with-ros2-in-cpp","text":"","title":"Developing the example controller with ROS2 in CPP"},{"location":"creating/","text":"Creating your own Starling Project \u00b6 This tutorial takes you through using the Starling templates repository to generate your own custom starling application. Creating your own Starling Project Prerequists Project Structure Planning Generating the base Starling Project Adding Nodes to your project What is in the templates cpp_ros2_node_onboard_template python_ros2_node_offboard_template ros2_msgs_template Dockerfile Running your new project Initialising Git Next Steps Prerequists \u00b6 In order to complete this tutorial, you will need the following installed. You may have already installed these within Getting Strted The template generation uses the cookiecutter tool for generating custom projects from a template. Then run: python3 -m pip install --user cookiecutter # or easy_install --user cookiecutter See cookiecutter installation for further details on different platforms. This will give you access to the cookiecutter command line interface. Recommendation is to sign up for Docker Hub and Github, necessary if you wish to fly your controller in the real world. Project Structure Planning \u00b6 Before diving in to creating your project, you first need to decide on the structure of the project. The structure is wholy determined by the application, and the functionality that is split between the central server and onboard each vehicle. Let's review our task for this tutorial: In this scene a number of drones take off and automatically fly to starting points equidistant around a circle of a given radius. They then start circling around the edge of the circle attempting to stay equidistant to their neighbours. It is determined that the vehicles have not been well tuned and can end up lagging, therefore a centralised server monitors all the vehicles and notifies them if they are lagging behind. A Starling Project is comprised of one or more ROS Nodes which each encompass one piece of functionality. In this project we can identify the need for the following: A node onboard the vehicle which can arm, takeoff, land and fly it in a circle of radius r from a given start location in a safe manner. A node offboard on the cetral server which receives vehicle locations, finds the ideal locations and then sends that information back to the vehicles. Through this we identify that we may also need to provide a set of custom messages for the communication of specific information between server and vehicle. Therefore this Starling Project will contain the source code for an onboard node, an offboard node and a set of custom messages. An important task is then to name these beforehand as we will need to refer to these names in the next step. By default we have named them the following, but you should endeavour to name them something better! Offboard node: template_python_node Onboard node: template_cpp_node Custom msgs: template_msgs Generating the base Starling Project \u00b6 The first step is to build your own Starling project. The following will start the process of using the template to generate the base starling project. In your workspace, run the following command. cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory starling_template It will follow by asking you to fill in a number of details. The value in the square brackets indicates the default value if you choose not to enter anything. Press Enter to go on to the next one. The inputs include the following. Name Description Full Name Your name used for documentaiton Email Your email address used for documentation Short Description A short description of your project added to the documentation and project files Project Name The name you have given to this Starling Project, make sure that you are happy with this as changing the name after fact is a bit of a pain. Github Username Optionally your github username for filling in the README and metadata Docker Username Optionally your docker hub username which is used for naming the Starling image. Will be used to upload to if you wish to push it online. Docker Image Name The name of the Starling image that this repository produces Docker Image Name Full An autogenerated name based on your username and image name, you can leave as the default unless you really want to change it. By default it is <Docker Username>/<Docker Image Name> Onboard ROS2 Package Name The name of the onboard controller which this containers Dockerfile will run in onboard mode. Offboard ROS2 Package Name The name of the offboard controller which this containers Dockerfile will run in offboard mode. Note: The last two entries should correspond to the node names you came up with in the planning phase. Note: The last two entries are for automatically populating the run.sh script. The run.sh script is the default script your project's Docker container runs on startup. You can leave these two as defaults and edit the run.sh script later. Once complete, the project will be generated into a folder named by your project_name . For example, the default project with name starling_controller produces a project with the following structure: starling_controller |-- buildtools |-- docker-bake.hcl |-- deployment |-- docker-compose.yml |-- kubernetes.yaml |-- starling_controller |-- run.sh |-- Dockerfile |-- LICENSE |-- Makefile |-- README.md We have the following folders and files. starling_controller will be populated by user created ros packages. Anything in this folder is directly copied to the Dockerfile and built. deployment contains a sample docker-compose file which runs a default simulation stack, and a sample kubernetes file for deployment, both will most definitely need to be edited. buildtools contains the specification that docker uses to build the container. It contains the naming for the docker image. Dockerfile contains the dockerfile which specifies the build steps for this project. It already specifies the installation of a number of dependencies, including libInterpolate interpolation library. Once generated, the Makefile can be used to build and run commands: cd <Your Application Name> # Go into the your new Starling application directory make # Will build the project make run # Will build and run the container make run_bash # Will build and run the container, putting you in a bash shell inside it. make help # Shows the help screen This should successfuly build your project container which you can try and run or inspect. Currently it has no funcionality so nothing can happen. Have a look inside the container using make run_bash . Note On windows you can either use WSL or have a look at some of the solutions in this link Adding Nodes to your project \u00b6 The generated project has no functionality right now. This repository contains other templates which will generate rosnodes for you. In particular cpp_ros2_node_onboard_template : Generates a ROS2 node, designed for running onboard the vehicle written in CPP. python_ros2_node_offboard_template : Generates a ROS2 node, designed for running offboard (central server) written in Python ros2_msgs_template : Generates a ROS2 msgs package which can be used by any ROS2 package within this container. These nodes can be added to your project using the following cookiecutter commands. Note that the packages should be generated into the starling_project_name directory of the base Starling project. Each of these commands are single line commands. # CPP Onboard cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory cpp_ros2_node_onboard_template -o starling_controller/starling_controller # Python Offboard cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory python_ros2_node_offboard_template -o starling_controller/starling_controller # Messages cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory ros2_msgs_template -o starling_controller/starling_controller Note the --directory option points cookiecutter to the correct template, the -o option specifies the output directory, in our case the output should be inside the created Starling project. Similar to the generating of the base project, these will ask a number of questions to you during the generation. In particular it will ask what the package_name is which will become the name of that particular node package. Name Default Description full_name starling_user Your name used for documentation email starling.user@starling.co.uk Your email address used for documentaiton year 2022 The year of creation for documentation package_name template_node The name of this ROS2 Node, make sure this is correct and then you note it down. It should match the ones given in the initial Starling setup short_description ROS2 node template A short description of the functionality of this node for documentation and project files custom_ros2_msgs_name template_msgs Important! The name of the custom msgs package name you have added as part of this starling project. The name must match exactly otherwise the default functionality will fail. Note convention for msg packages is to have a package name of format <mymessages>_msgs , e.g. circle_experiment_msgs . Note For those familiar with ROS1, it is ROS2 convention to keep messages in a seperate package to the ros nodes themselves. This should give you a file tree that looks something like the following (of course with your package names instead) starling_controller |-- buildtools |-- docker-bake.hcl |-- deployment |-- docker-compose.yml |-- kubernetes.yaml |-- starling_controller |-- template_onboard_controller |-- ... |-- template_offboard_controller |-- ... |-- template_msgs |-- ... |-- run.sh |-- Dockerfile |-- LICENSE |-- Makefile |-- README.md That being said, the nodes can be run standalone for your own projects, one at a time, or whenever you need a new node within your project. Once these packages have been placed within the correct directory inside the Starling project, you can simply run make to check that they are successfully built. What is in the templates \u00b6 The set of node templates above should create you a project which runs the example scenario specifically developed for the purpose of this tutorial. This example has been designed to show the development of an onboard and an offboard container, as well as demonstratee communication between the two. The scenario is as follows: We have \\(n\\) n drones which we would like to fly equidistant around a circle of fixed radius at a initial velocity. A central server will send each drone an id \\(i<n\\) i<n to determine its start location around the circle. Once received the drones will start flying around the circle and send its current position to the server. The server collates the drones informations to determine if any of the drones are lagging or ahead of where they should be. This ideal position is sent back to each drone. The drone adjusts its velocity to try based on the error to match with the ideal. With this in mind we can quickly run through what is in each of the ros node templates. Note: More detail about the actual functionality within these nodes will be in this tutorial section cpp_ros2_node_onboard_template \u00b6 |-- CMakeLists.txt |-- include | |-- controller.hpp | |-- main.hpp | `-- state.hpp |-- launch | `-- template_cpp_node.launch.xml |-- package.xml `-- src |-- controller.cpp `-- main.cpp This node runs onboard the vehicle and interfaces with MAVROS. It contains a state machine with functionality to arm, takeoff, land, loiter and takes care of safety functionality. CMakeLists.txt : contains the instructions to build this rosnode. This includes specifying dependencies and extra libraries (e.g. messages such as geometry_msgs or external dependencies). It also specifies the name of the binary containing all of your functionality. By default this is controller . include and src : In CPP, your code files are split into header files (specifying object definitions) and source files (specifying object functionality), these are stored here launch : contains a ROS launch file. We use XML notation to describe how your rosnode gets launched, including extra parameters or other changes you want to make at runtime instead of buildtime. This is what gets run to run your rosnode package.xml : ROS2 Metadata file specifying ros2 dependencies of your project. As a brief overview of the code files: main.hpp and main.cpp : Contains the program entrypoint function and the core of the ros node. It contains all of the core functionality to fly a vehicle as well as the state machine. It includes the user controller specified in controller.hpp to be expected to run during the execution phase of the state machine. controller.hpp and controller.cpp : For the majority of simple applications, a user should only need to provide their own version of these files. The controller contains an initialisation and loop function which a user can fill in. state.hpp : A header only file containing the states of the state machine. python_ros2_node_offboard_template \u00b6 |-- package.xml |-- resource | `-- template_python_node |-- setup.cfg |-- setup.py |-- template_python_node | |-- __init__.py | `-- main.py `-- test |-- test_copyright.py |-- test_flake8.py `-- test_pep257.py This node runs offboard on the central server. It is designed to run on its own with no external dependence on anything outside of the application. package.xml : ROS2 Metadata file specifying ros2 dependencies of your project. resource : A python ros package special folder, no need to touch setup.cfg : Configuration file specifying where key resources are setup.py : The python equivalent of CMakeLists.txt and contains the instructions to build this rosnode. It specifies which resources are copied over and available to the rosnode at runtime. Also specifies the name of the binary, and which function it is intended to run. By default this is controller <your rosnode name> e.g. template_python_node : The source directory for your python files. test : A number of testing utilities which can be run with pytest. Currently not used. As a brief overview of code files: main.py : Contains a ros node which uses a timer to repeat poll the current state of vehicles on the network at given intervals. It then performs the calculation of ideal vehicle location and sends that to the vehicles. ros2_msgs_template \u00b6 |-- CMakeLists.txt |-- msg | |-- NotifyVehicles.msg | `-- TargetAngle.msg `-- package.xml This node is purely for specifying and building the custom ros messages in our application. Any application which uses these messages need a compiled version of this node. CMakeLists.txt : contains the instructions to build the messages. Any extra messages or services need to be added to the CMakeLists. msg : A list of specified custom messages. package.xml : ROS2 Metadata file specifying ros2 dependencies of your project. Dockerfile \u00b6 As mentioned in the previous tutorial , a Dockerfile is used as a recipe to build your controller docker container. The Dockerfile in this template contains the command line instructions to build your controller. By default it will install a number of useful libraries for compatibility. If you need any new libraries, you will have to add their installation here It then essentially copies in all of the rosnodes specified within the project name directory and runs them through the standard ROS2 build tool named colcon . It also copies over the run.sh file which the Dockerfile will run on container startup. Therefore the run.sh should have the instructions for running your applications. Thankfully you do not need to run docker build automatically as we have setup a special build system which is wrapped up inside the Makefile . Running your new project \u00b6 With your project now constructed, you can now re-run your container with the same make commands as earlier. cd <Your Application Name> # Go into the your new Starling application directory make run # Will build and run the container This will build a container called <Docker Username>/<Docker Image Name> with tag latest e.g. myname/starling_template:latest This will build start the onboard controller by default, but it will start complaining that it hasn't received any state or position messages for initialisation. This is normal for now! If you want to start the offboard controller, you can add the extra option ENV=\"-e OFFBOARD=true\" to the make command like so make run ENV=\"-e OFFBOARD=true\" . Where it will start trying to identify the number of vehicles on the network, but of course it cannot find any! You can have a look inside both container using make run_bash . Initialising Git \u00b6 Optionally, at this point you can start version controller on your project in order to save your progress. To initalise git and create your first commit, go to the root of your project and run: git init git add -A git commit -m \"Initial Commit\" If you want to push this code onto github, you can follow this tutorial . In short, create an empty github repository of the same name in your github account, then change the remote locally: git remote add origin <remote repository URL> git remote -v git push origin master Next Steps \u00b6 Congratulations, you now have your own Starling application! It doesn't quite have any functionality just yet but before we get to adding some, it's important to understand how you run the simulation for you to test your controller against!","title":"4. Creating your own Starling project"},{"location":"creating/#creating-your-own-starling-project","text":"This tutorial takes you through using the Starling templates repository to generate your own custom starling application. Creating your own Starling Project Prerequists Project Structure Planning Generating the base Starling Project Adding Nodes to your project What is in the templates cpp_ros2_node_onboard_template python_ros2_node_offboard_template ros2_msgs_template Dockerfile Running your new project Initialising Git Next Steps","title":"Creating your own Starling Project"},{"location":"creating/#prerequists","text":"In order to complete this tutorial, you will need the following installed. You may have already installed these within Getting Strted The template generation uses the cookiecutter tool for generating custom projects from a template. Then run: python3 -m pip install --user cookiecutter # or easy_install --user cookiecutter See cookiecutter installation for further details on different platforms. This will give you access to the cookiecutter command line interface. Recommendation is to sign up for Docker Hub and Github, necessary if you wish to fly your controller in the real world.","title":"Prerequists"},{"location":"creating/#project-structure-planning","text":"Before diving in to creating your project, you first need to decide on the structure of the project. The structure is wholy determined by the application, and the functionality that is split between the central server and onboard each vehicle. Let's review our task for this tutorial: In this scene a number of drones take off and automatically fly to starting points equidistant around a circle of a given radius. They then start circling around the edge of the circle attempting to stay equidistant to their neighbours. It is determined that the vehicles have not been well tuned and can end up lagging, therefore a centralised server monitors all the vehicles and notifies them if they are lagging behind. A Starling Project is comprised of one or more ROS Nodes which each encompass one piece of functionality. In this project we can identify the need for the following: A node onboard the vehicle which can arm, takeoff, land and fly it in a circle of radius r from a given start location in a safe manner. A node offboard on the cetral server which receives vehicle locations, finds the ideal locations and then sends that information back to the vehicles. Through this we identify that we may also need to provide a set of custom messages for the communication of specific information between server and vehicle. Therefore this Starling Project will contain the source code for an onboard node, an offboard node and a set of custom messages. An important task is then to name these beforehand as we will need to refer to these names in the next step. By default we have named them the following, but you should endeavour to name them something better! Offboard node: template_python_node Onboard node: template_cpp_node Custom msgs: template_msgs","title":"Project Structure Planning"},{"location":"creating/#generating-the-base-starling-project","text":"The first step is to build your own Starling project. The following will start the process of using the template to generate the base starling project. In your workspace, run the following command. cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory starling_template It will follow by asking you to fill in a number of details. The value in the square brackets indicates the default value if you choose not to enter anything. Press Enter to go on to the next one. The inputs include the following. Name Description Full Name Your name used for documentaiton Email Your email address used for documentation Short Description A short description of your project added to the documentation and project files Project Name The name you have given to this Starling Project, make sure that you are happy with this as changing the name after fact is a bit of a pain. Github Username Optionally your github username for filling in the README and metadata Docker Username Optionally your docker hub username which is used for naming the Starling image. Will be used to upload to if you wish to push it online. Docker Image Name The name of the Starling image that this repository produces Docker Image Name Full An autogenerated name based on your username and image name, you can leave as the default unless you really want to change it. By default it is <Docker Username>/<Docker Image Name> Onboard ROS2 Package Name The name of the onboard controller which this containers Dockerfile will run in onboard mode. Offboard ROS2 Package Name The name of the offboard controller which this containers Dockerfile will run in offboard mode. Note: The last two entries should correspond to the node names you came up with in the planning phase. Note: The last two entries are for automatically populating the run.sh script. The run.sh script is the default script your project's Docker container runs on startup. You can leave these two as defaults and edit the run.sh script later. Once complete, the project will be generated into a folder named by your project_name . For example, the default project with name starling_controller produces a project with the following structure: starling_controller |-- buildtools |-- docker-bake.hcl |-- deployment |-- docker-compose.yml |-- kubernetes.yaml |-- starling_controller |-- run.sh |-- Dockerfile |-- LICENSE |-- Makefile |-- README.md We have the following folders and files. starling_controller will be populated by user created ros packages. Anything in this folder is directly copied to the Dockerfile and built. deployment contains a sample docker-compose file which runs a default simulation stack, and a sample kubernetes file for deployment, both will most definitely need to be edited. buildtools contains the specification that docker uses to build the container. It contains the naming for the docker image. Dockerfile contains the dockerfile which specifies the build steps for this project. It already specifies the installation of a number of dependencies, including libInterpolate interpolation library. Once generated, the Makefile can be used to build and run commands: cd <Your Application Name> # Go into the your new Starling application directory make # Will build the project make run # Will build and run the container make run_bash # Will build and run the container, putting you in a bash shell inside it. make help # Shows the help screen This should successfuly build your project container which you can try and run or inspect. Currently it has no funcionality so nothing can happen. Have a look inside the container using make run_bash . Note On windows you can either use WSL or have a look at some of the solutions in this link","title":"Generating the base Starling Project"},{"location":"creating/#adding-nodes-to-your-project","text":"The generated project has no functionality right now. This repository contains other templates which will generate rosnodes for you. In particular cpp_ros2_node_onboard_template : Generates a ROS2 node, designed for running onboard the vehicle written in CPP. python_ros2_node_offboard_template : Generates a ROS2 node, designed for running offboard (central server) written in Python ros2_msgs_template : Generates a ROS2 msgs package which can be used by any ROS2 package within this container. These nodes can be added to your project using the following cookiecutter commands. Note that the packages should be generated into the starling_project_name directory of the base Starling project. Each of these commands are single line commands. # CPP Onboard cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory cpp_ros2_node_onboard_template -o starling_controller/starling_controller # Python Offboard cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory python_ros2_node_offboard_template -o starling_controller/starling_controller # Messages cookiecutter https://github.com/StarlingUAS/starling_controller_templates.git --directory ros2_msgs_template -o starling_controller/starling_controller Note the --directory option points cookiecutter to the correct template, the -o option specifies the output directory, in our case the output should be inside the created Starling project. Similar to the generating of the base project, these will ask a number of questions to you during the generation. In particular it will ask what the package_name is which will become the name of that particular node package. Name Default Description full_name starling_user Your name used for documentation email starling.user@starling.co.uk Your email address used for documentaiton year 2022 The year of creation for documentation package_name template_node The name of this ROS2 Node, make sure this is correct and then you note it down. It should match the ones given in the initial Starling setup short_description ROS2 node template A short description of the functionality of this node for documentation and project files custom_ros2_msgs_name template_msgs Important! The name of the custom msgs package name you have added as part of this starling project. The name must match exactly otherwise the default functionality will fail. Note convention for msg packages is to have a package name of format <mymessages>_msgs , e.g. circle_experiment_msgs . Note For those familiar with ROS1, it is ROS2 convention to keep messages in a seperate package to the ros nodes themselves. This should give you a file tree that looks something like the following (of course with your package names instead) starling_controller |-- buildtools |-- docker-bake.hcl |-- deployment |-- docker-compose.yml |-- kubernetes.yaml |-- starling_controller |-- template_onboard_controller |-- ... |-- template_offboard_controller |-- ... |-- template_msgs |-- ... |-- run.sh |-- Dockerfile |-- LICENSE |-- Makefile |-- README.md That being said, the nodes can be run standalone for your own projects, one at a time, or whenever you need a new node within your project. Once these packages have been placed within the correct directory inside the Starling project, you can simply run make to check that they are successfully built.","title":"Adding Nodes to your project"},{"location":"creating/#what-is-in-the-templates","text":"The set of node templates above should create you a project which runs the example scenario specifically developed for the purpose of this tutorial. This example has been designed to show the development of an onboard and an offboard container, as well as demonstratee communication between the two. The scenario is as follows: We have \\(n\\) n drones which we would like to fly equidistant around a circle of fixed radius at a initial velocity. A central server will send each drone an id \\(i<n\\) i<n to determine its start location around the circle. Once received the drones will start flying around the circle and send its current position to the server. The server collates the drones informations to determine if any of the drones are lagging or ahead of where they should be. This ideal position is sent back to each drone. The drone adjusts its velocity to try based on the error to match with the ideal. With this in mind we can quickly run through what is in each of the ros node templates. Note: More detail about the actual functionality within these nodes will be in this tutorial section","title":"What is in the templates"},{"location":"creating/#cpp_ros2_node_onboard_template","text":"|-- CMakeLists.txt |-- include | |-- controller.hpp | |-- main.hpp | `-- state.hpp |-- launch | `-- template_cpp_node.launch.xml |-- package.xml `-- src |-- controller.cpp `-- main.cpp This node runs onboard the vehicle and interfaces with MAVROS. It contains a state machine with functionality to arm, takeoff, land, loiter and takes care of safety functionality. CMakeLists.txt : contains the instructions to build this rosnode. This includes specifying dependencies and extra libraries (e.g. messages such as geometry_msgs or external dependencies). It also specifies the name of the binary containing all of your functionality. By default this is controller . include and src : In CPP, your code files are split into header files (specifying object definitions) and source files (specifying object functionality), these are stored here launch : contains a ROS launch file. We use XML notation to describe how your rosnode gets launched, including extra parameters or other changes you want to make at runtime instead of buildtime. This is what gets run to run your rosnode package.xml : ROS2 Metadata file specifying ros2 dependencies of your project. As a brief overview of the code files: main.hpp and main.cpp : Contains the program entrypoint function and the core of the ros node. It contains all of the core functionality to fly a vehicle as well as the state machine. It includes the user controller specified in controller.hpp to be expected to run during the execution phase of the state machine. controller.hpp and controller.cpp : For the majority of simple applications, a user should only need to provide their own version of these files. The controller contains an initialisation and loop function which a user can fill in. state.hpp : A header only file containing the states of the state machine.","title":"cpp_ros2_node_onboard_template"},{"location":"creating/#python_ros2_node_offboard_template","text":"|-- package.xml |-- resource | `-- template_python_node |-- setup.cfg |-- setup.py |-- template_python_node | |-- __init__.py | `-- main.py `-- test |-- test_copyright.py |-- test_flake8.py `-- test_pep257.py This node runs offboard on the central server. It is designed to run on its own with no external dependence on anything outside of the application. package.xml : ROS2 Metadata file specifying ros2 dependencies of your project. resource : A python ros package special folder, no need to touch setup.cfg : Configuration file specifying where key resources are setup.py : The python equivalent of CMakeLists.txt and contains the instructions to build this rosnode. It specifies which resources are copied over and available to the rosnode at runtime. Also specifies the name of the binary, and which function it is intended to run. By default this is controller <your rosnode name> e.g. template_python_node : The source directory for your python files. test : A number of testing utilities which can be run with pytest. Currently not used. As a brief overview of code files: main.py : Contains a ros node which uses a timer to repeat poll the current state of vehicles on the network at given intervals. It then performs the calculation of ideal vehicle location and sends that to the vehicles.","title":"python_ros2_node_offboard_template"},{"location":"creating/#ros2_msgs_template","text":"|-- CMakeLists.txt |-- msg | |-- NotifyVehicles.msg | `-- TargetAngle.msg `-- package.xml This node is purely for specifying and building the custom ros messages in our application. Any application which uses these messages need a compiled version of this node. CMakeLists.txt : contains the instructions to build the messages. Any extra messages or services need to be added to the CMakeLists. msg : A list of specified custom messages. package.xml : ROS2 Metadata file specifying ros2 dependencies of your project.","title":"ros2_msgs_template"},{"location":"creating/#dockerfile","text":"As mentioned in the previous tutorial , a Dockerfile is used as a recipe to build your controller docker container. The Dockerfile in this template contains the command line instructions to build your controller. By default it will install a number of useful libraries for compatibility. If you need any new libraries, you will have to add their installation here It then essentially copies in all of the rosnodes specified within the project name directory and runs them through the standard ROS2 build tool named colcon . It also copies over the run.sh file which the Dockerfile will run on container startup. Therefore the run.sh should have the instructions for running your applications. Thankfully you do not need to run docker build automatically as we have setup a special build system which is wrapped up inside the Makefile .","title":"Dockerfile"},{"location":"creating/#running-your-new-project","text":"With your project now constructed, you can now re-run your container with the same make commands as earlier. cd <Your Application Name> # Go into the your new Starling application directory make run # Will build and run the container This will build a container called <Docker Username>/<Docker Image Name> with tag latest e.g. myname/starling_template:latest This will build start the onboard controller by default, but it will start complaining that it hasn't received any state or position messages for initialisation. This is normal for now! If you want to start the offboard controller, you can add the extra option ENV=\"-e OFFBOARD=true\" to the make command like so make run ENV=\"-e OFFBOARD=true\" . Where it will start trying to identify the number of vehicles on the network, but of course it cannot find any! You can have a look inside both container using make run_bash .","title":"Running your new project"},{"location":"creating/#initialising-git","text":"Optionally, at this point you can start version controller on your project in order to save your progress. To initalise git and create your first commit, go to the root of your project and run: git init git add -A git commit -m \"Initial Commit\" If you want to push this code onto github, you can follow this tutorial . In short, create an empty github repository of the same name in your github account, then change the remote locally: git remote add origin <remote repository URL> git remote -v git push origin master","title":"Initialising Git"},{"location":"creating/#next-steps","text":"Congratulations, you now have your own Starling application! It doesn't quite have any functionality just yet but before we get to adding some, it's important to understand how you run the simulation for you to test your controller against!","title":"Next Steps"},{"location":"docker/","text":"Docker and Containerisation \u00b6 This tutorial gives a brief introduction to a key element of Starling - containerisation. By the end you will hopefully have an idea of what containerisation is, what docker is, how to use it, and how we use it within Starling. This is adapted from the Duckietown Docker Docs , Docker Docs tutorial , and a number of other resources. Docker and Containerisation Introduction What is Containerisation and Docker Docker Concepts in more detail Starling Container Ecosystem Using Docker with Starling Getting and Running Containers Creating Containers Layer Caching Inspecting a container Next Steps Introduction \u00b6 What is Containerisation and Docker \u00b6 It would be nice to give a computer - any computer with an internet connection - a short string of ASCII characters (say via a keyboard), press enter, and return to see some program running. Forget about where the program was built or what software you happened to be running at the time (this can be checked, and we can fetch the necessary dependencies). Sounds simple, right? In fact, this is an engineering task that has taken thousands of the world\u2019s brightest developers many decades to implement. Thanks to the magic of container technology we now can run any Linux program on almost any networked device on the planet, as is. All of the environment preparation, installation and configuration steps can be automated from start to finish. Depending on how much network bandwidth you have, it might take a while, but that\u2019s all right. All you need to do is type the string correctly. Docker is one very widely used example of containerisation technology, and the one we make use of in Starling. They provide a large number of tools and programs to help us contain, develop, test and deploy our containers to the real world. If you followed the getting started , you should hopefully have done the full docker install. If not, you can run the following command from a linux command line to install basic docker. curl -sSL https://get.docker.com/ | sh Docker Concepts in more detail \u00b6 Adapted from Docker Resources A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. Container images become containers at runtime and in the case of Docker containers \u2013 images become containers when they run on Docker Engine. Available for both Linux and Windows-based applications, containerized software will always run the same, regardless of the infrastructure. Containers isolate software from its environment and ensure that it works uniformly despite differences for instance between development and staging. Containers are Standard (can run anywhere), Lightweight (Share low level machine system and not the whole Operating System) and Secure (Each application is as isolated as possible). For us this also translates to providing Reproduceable and Reusable systems. On the left, Containers are an abstraction at the app layer that packages code and dependencies together. Multiple containers can run on the same machine and share the OS kernel with other containers, each running as isolated processes in user space. Containers take up less space than VMs (container images are typically tens of MBs in size), can handle more applications and require fewer VMs and Operating systems. On the right, Virtual machines (VMs) are an abstraction of physical hardware turning one server into many servers. The hypervisor allows multiple VMs to run on a single machine. Each VM includes a full copy of an operating system, the application, necessary binaries and libraries \u2013 taking up tens of GBs. VMs can also be slow to boot. Starling Container Ecosystem \u00b6 The purpose of Starling is to allow you to quickly and easily install and run a UAV simulation within a simulated environment, so that you can test your developed controllers against a semi-realistic scenario, to then test in the real world Therefore Starling is a set of pre-built programs/executables, some of which are pre-configured for the following: Running a Physics Simulation with Visualisation Running the Drone autopilot control software locally (a.k.a Software In The Loop or SITL) Running the interface between Mavlink and other protocols such as the Robot Operating System (ROS) And many others... These pre-built containers are all available in the StarlingUAS repository on github and on Docker Hub. Together these containers form a modular ecosystem of drone systems which can be composed together to develop software for real drones. Any controllers developed via the simulator can be directly ported to run on a real drone. Using Docker with Starling \u00b6 Getting and Running Containers \u00b6 Every docker container is registered to a developer or organisation. In Starling, our docker organisation is known as uobflightlabstarling . Within our organisation, we have a large number of Docker containers available. These Docker containers live inside container registries (such as DockerHub), which are servers that host Docker images. A Docker image is one particular version or snapshot of a container and is basically a filesystem snapshot - a single file that contains everything you need to run our container. You can manually fetch one of our core containers called starling-mavros from docker hub using: docker pull uobflightlabstarling/starling-mavros You can also try and pull one of our simulation containers: docker pull uobflightlabstarling/starling-sim-iris-px4-flightarena:latest This might take a few minutes to download depending on internet connection (some containers like the simulation can be quite big!). Once downloaded, to see a list of Docker images on your machine, run: docker images Every image has an image ID, a name and a tag REPOSITORY TAG IMAGE ID CREATED SIZE uobflightlabstarling/starling-sim-iris-px4-flightarena latest 62d7f96637cf 3 weeks ago 5.97GB uobflightlabstarling/starling-mavros latest b70812c16731 5 months ago 2.06GB To run a Docker container, type the repository name, like so: docker run uobflightlabstarling/starling-mavros # Or with the tag if you want to run a specific tag (version) of that container docker run uobflightlabstarling/starling-mavros:latest In another terminal, you can see what is currently running using: docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4fd1e0948f23 uobflightlabstarling/starling-mavros \"/ros_entrypoint.sh \u2026\" 46 seconds ago Up 45 seconds vigilant_nobel Note how your the running container has a container ID , a base image you ran, and at the end, a funny name vigilant_noble . This funny name is an alias for the container ID. To stop the container, simply press ctrl+c in the terminal which you ran docker run . As a second example, you can similarly try and run the simulator, this time also specifying a port mapping to let you see the simulator in your web-browser. docker run -p 8080:8080 uobflightlabstarling/starling-sim-iris-px4-flightarena Then you can navigate to localhost:8080 in your web browser to see the simulator. You should hopefully see something like the following: You can use the cursor to move around the environment, we will be coming back to the simulator in a later section . To stop the simulator, you can try and use ctrl+c , but sometimes this doenst work. Another way is to first get the container ID or name like before: docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6a4bd538118c uobflightlabstarling/starling-sim-iris-px4-flightarena \"/entrypoint.sh ros2\u2026\" 2 minutes ago Up 2 minutes 7681/tcp, 11345/tcp, 0.0.0.0:8080->8080/tcp trusting_diffie See how the name is trusting_diffie with ID 6a4bd538118c . You can then explicitly stop the container by running (it can sometimes take a minute). docker stop trusting_diffie # or docker stop 6a4bd538118c Dont forget to also remove the container afterwards docker rm trusting_diffie # or docker rm 6a4bd538118c Creating Containers \u00b6 To create a Docker image we write a recipe, called a Dockerfile . A Dockerfile is a text file that specifies the commands required to create a Docker image, typically by modifying an existing container image using a scripting interface. They also have special keywords (which are always CAPITALIZED), like FROM , RUN , ENTRYPOINT and so on. For example, create a file called Dockerfile with the following content: FROM ros:foxy # Defines the base image RUN touch new_file1 # new_file1 will be part of our snapshot CMD ls -l # Default command to be run when the container is started Now, to build the image we can simply run: docker build -t your/duck:v3 . # Where '.' is the directory containing your Dockerfile You should see something like: Sending build context to Docker daemon 2.048kB Step 1/3 : FROM uobflightlabstarling/starling-mavros --- ea2f90g8de9e Step 2/3 : RUN touch new_file1 --- e3b75gt9zyc4 Step 3/3 : CMD ls -l --- Running in 14f834yud59 Removing intermediate container 14f834yud59 --- 05a3bd381fc2 Successfully built 05a3bd381fc2 Successfully tagged your/duck:v3 Now run the command docker images in your terminal, and you should see an image called your/duck with tag v3: docker images REPOSITORY TAG IMAGE ID CREATED SIZE your/duck v3 ea2f90g8de9e 1 minute ago 2.06GB uobflightlabstarling/starling-sim-iris-px4-flightarena latest 62d7f96637cf 3 weeks ago 5.97GB uobflightlabstarling/starling-mavros latest b70812c16731 5 months ago 2.06GB This procedure is identical to the snapshot method we performed earlier, but the result is much cleaner. Now, instead of needing to carry around a 2.06GB BLOB, we can just store the 4KB text file and rest assured that all our important setup commands are contained within. Similar to before, we can simply run: docker run -it your/duck:v3 total 0 -rw-r--r-- 1 root root 0 May 21 21:35 new_file1 Notice that as soon as we run the container, Docker will execute the ls -l command as specified by the Dockerfile, revealing new_file1 was stored in the image. However we can still override ls -l by passing a command line argument: docker run -it your/duck:v3 [custom command] In the next tutorial, we will go into more detail in how these Dockerfiles are constructed for us. Layer Caching \u00b6 An important concept in Docker is the layers . In the previous section you may think that every time we build, we end up having to copy over the entire parent container. e.g. your/duck:v3 takes up another 2Gb of storage space! In actual fact, it (thankfully) does not, because under the hood the executable does not exist as one giant individible binary. It is in fact split into multiple independnet layers which can be shared in between images! Essentially each RUN line in your Dockerfile is compiled into a new layer placed upon the previous layers. This is helpful as if you try to build your container again, unless you change something, those previous layers are cached by Docker to be used instead of rebuilding the entire thing from scratch! Inspecting a container \u00b6 One of the downsides of containers is that manipulating files and inspecting the their state is not as simple. Previously, you could just browser through your own file system and check things. Now that a container has its own file system, its not as clear how you could check things have been set up correctly, or test run commands manually or similar. There are a number of different ways, but the simplest way is to exec into a running container. As an example, you can run starling-mavros again in one terminal. docker run uobflightlabstarling/starling-mavros In another terminal, identify the container ID or name by using docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 81b7dfb6c443 uobflightlabstarling/starling-mavros \"/ros_entrypoint.sh \u2026\" 3 seconds ago Up 2 seconds angry_yalow Note: The IDs have changed from the previous time we ran this container. Sometimes you want containers to persist, or do not want to delete them for testing and such. We can then use the ID of 81b7dfb6c443 or its name angry_yalow to exec into a container to run a command: docker exec -it angry_yalow [command] For example, in most cases it will be most useful to open up a bash terminal to inspect contents: docker exec -it angry_yalow bash root@81b7dfb6c443:/ros_ws# This opens up a terminal inside the container for you to navigate around and inspect things as you wish, in a similar manner to if you SSH'd into another machine. Note: Use the cat command to view the contents of files. Note: These containers have almost no tools to keep them slim. If you want to edit things, you will need to download a command line file editor. Run apt-get update then install an editor like nano with apt-get install nano . Next Steps \u00b6 Hopefully you now have a decent understanding of what containerisation is and its purpose within Starling. You have also had a go at using the Docker command line tool to pull, run, build and inspect Starling containers going forward. With all that, we are now at a point where you can start creating your own containers to use!","title":"3. Docker and Containerisation"},{"location":"docker/#docker-and-containerisation","text":"This tutorial gives a brief introduction to a key element of Starling - containerisation. By the end you will hopefully have an idea of what containerisation is, what docker is, how to use it, and how we use it within Starling. This is adapted from the Duckietown Docker Docs , Docker Docs tutorial , and a number of other resources. Docker and Containerisation Introduction What is Containerisation and Docker Docker Concepts in more detail Starling Container Ecosystem Using Docker with Starling Getting and Running Containers Creating Containers Layer Caching Inspecting a container Next Steps","title":"Docker and Containerisation"},{"location":"docker/#introduction","text":"","title":"Introduction"},{"location":"docker/#what-is-containerisation-and-docker","text":"It would be nice to give a computer - any computer with an internet connection - a short string of ASCII characters (say via a keyboard), press enter, and return to see some program running. Forget about where the program was built or what software you happened to be running at the time (this can be checked, and we can fetch the necessary dependencies). Sounds simple, right? In fact, this is an engineering task that has taken thousands of the world\u2019s brightest developers many decades to implement. Thanks to the magic of container technology we now can run any Linux program on almost any networked device on the planet, as is. All of the environment preparation, installation and configuration steps can be automated from start to finish. Depending on how much network bandwidth you have, it might take a while, but that\u2019s all right. All you need to do is type the string correctly. Docker is one very widely used example of containerisation technology, and the one we make use of in Starling. They provide a large number of tools and programs to help us contain, develop, test and deploy our containers to the real world. If you followed the getting started , you should hopefully have done the full docker install. If not, you can run the following command from a linux command line to install basic docker. curl -sSL https://get.docker.com/ | sh","title":"What is Containerisation and Docker"},{"location":"docker/#docker-concepts-in-more-detail","text":"Adapted from Docker Resources A container is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another. A Docker container image is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings. Container images become containers at runtime and in the case of Docker containers \u2013 images become containers when they run on Docker Engine. Available for both Linux and Windows-based applications, containerized software will always run the same, regardless of the infrastructure. Containers isolate software from its environment and ensure that it works uniformly despite differences for instance between development and staging. Containers are Standard (can run anywhere), Lightweight (Share low level machine system and not the whole Operating System) and Secure (Each application is as isolated as possible). For us this also translates to providing Reproduceable and Reusable systems. On the left, Containers are an abstraction at the app layer that packages code and dependencies together. Multiple containers can run on the same machine and share the OS kernel with other containers, each running as isolated processes in user space. Containers take up less space than VMs (container images are typically tens of MBs in size), can handle more applications and require fewer VMs and Operating systems. On the right, Virtual machines (VMs) are an abstraction of physical hardware turning one server into many servers. The hypervisor allows multiple VMs to run on a single machine. Each VM includes a full copy of an operating system, the application, necessary binaries and libraries \u2013 taking up tens of GBs. VMs can also be slow to boot.","title":"Docker Concepts in more detail"},{"location":"docker/#starling-container-ecosystem","text":"The purpose of Starling is to allow you to quickly and easily install and run a UAV simulation within a simulated environment, so that you can test your developed controllers against a semi-realistic scenario, to then test in the real world Therefore Starling is a set of pre-built programs/executables, some of which are pre-configured for the following: Running a Physics Simulation with Visualisation Running the Drone autopilot control software locally (a.k.a Software In The Loop or SITL) Running the interface between Mavlink and other protocols such as the Robot Operating System (ROS) And many others... These pre-built containers are all available in the StarlingUAS repository on github and on Docker Hub. Together these containers form a modular ecosystem of drone systems which can be composed together to develop software for real drones. Any controllers developed via the simulator can be directly ported to run on a real drone.","title":"Starling Container Ecosystem"},{"location":"docker/#using-docker-with-starling","text":"","title":"Using Docker with Starling"},{"location":"docker/#getting-and-running-containers","text":"Every docker container is registered to a developer or organisation. In Starling, our docker organisation is known as uobflightlabstarling . Within our organisation, we have a large number of Docker containers available. These Docker containers live inside container registries (such as DockerHub), which are servers that host Docker images. A Docker image is one particular version or snapshot of a container and is basically a filesystem snapshot - a single file that contains everything you need to run our container. You can manually fetch one of our core containers called starling-mavros from docker hub using: docker pull uobflightlabstarling/starling-mavros You can also try and pull one of our simulation containers: docker pull uobflightlabstarling/starling-sim-iris-px4-flightarena:latest This might take a few minutes to download depending on internet connection (some containers like the simulation can be quite big!). Once downloaded, to see a list of Docker images on your machine, run: docker images Every image has an image ID, a name and a tag REPOSITORY TAG IMAGE ID CREATED SIZE uobflightlabstarling/starling-sim-iris-px4-flightarena latest 62d7f96637cf 3 weeks ago 5.97GB uobflightlabstarling/starling-mavros latest b70812c16731 5 months ago 2.06GB To run a Docker container, type the repository name, like so: docker run uobflightlabstarling/starling-mavros # Or with the tag if you want to run a specific tag (version) of that container docker run uobflightlabstarling/starling-mavros:latest In another terminal, you can see what is currently running using: docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4fd1e0948f23 uobflightlabstarling/starling-mavros \"/ros_entrypoint.sh \u2026\" 46 seconds ago Up 45 seconds vigilant_nobel Note how your the running container has a container ID , a base image you ran, and at the end, a funny name vigilant_noble . This funny name is an alias for the container ID. To stop the container, simply press ctrl+c in the terminal which you ran docker run . As a second example, you can similarly try and run the simulator, this time also specifying a port mapping to let you see the simulator in your web-browser. docker run -p 8080:8080 uobflightlabstarling/starling-sim-iris-px4-flightarena Then you can navigate to localhost:8080 in your web browser to see the simulator. You should hopefully see something like the following: You can use the cursor to move around the environment, we will be coming back to the simulator in a later section . To stop the simulator, you can try and use ctrl+c , but sometimes this doenst work. Another way is to first get the container ID or name like before: docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6a4bd538118c uobflightlabstarling/starling-sim-iris-px4-flightarena \"/entrypoint.sh ros2\u2026\" 2 minutes ago Up 2 minutes 7681/tcp, 11345/tcp, 0.0.0.0:8080->8080/tcp trusting_diffie See how the name is trusting_diffie with ID 6a4bd538118c . You can then explicitly stop the container by running (it can sometimes take a minute). docker stop trusting_diffie # or docker stop 6a4bd538118c Dont forget to also remove the container afterwards docker rm trusting_diffie # or docker rm 6a4bd538118c","title":"Getting and Running Containers"},{"location":"docker/#creating-containers","text":"To create a Docker image we write a recipe, called a Dockerfile . A Dockerfile is a text file that specifies the commands required to create a Docker image, typically by modifying an existing container image using a scripting interface. They also have special keywords (which are always CAPITALIZED), like FROM , RUN , ENTRYPOINT and so on. For example, create a file called Dockerfile with the following content: FROM ros:foxy # Defines the base image RUN touch new_file1 # new_file1 will be part of our snapshot CMD ls -l # Default command to be run when the container is started Now, to build the image we can simply run: docker build -t your/duck:v3 . # Where '.' is the directory containing your Dockerfile You should see something like: Sending build context to Docker daemon 2.048kB Step 1/3 : FROM uobflightlabstarling/starling-mavros --- ea2f90g8de9e Step 2/3 : RUN touch new_file1 --- e3b75gt9zyc4 Step 3/3 : CMD ls -l --- Running in 14f834yud59 Removing intermediate container 14f834yud59 --- 05a3bd381fc2 Successfully built 05a3bd381fc2 Successfully tagged your/duck:v3 Now run the command docker images in your terminal, and you should see an image called your/duck with tag v3: docker images REPOSITORY TAG IMAGE ID CREATED SIZE your/duck v3 ea2f90g8de9e 1 minute ago 2.06GB uobflightlabstarling/starling-sim-iris-px4-flightarena latest 62d7f96637cf 3 weeks ago 5.97GB uobflightlabstarling/starling-mavros latest b70812c16731 5 months ago 2.06GB This procedure is identical to the snapshot method we performed earlier, but the result is much cleaner. Now, instead of needing to carry around a 2.06GB BLOB, we can just store the 4KB text file and rest assured that all our important setup commands are contained within. Similar to before, we can simply run: docker run -it your/duck:v3 total 0 -rw-r--r-- 1 root root 0 May 21 21:35 new_file1 Notice that as soon as we run the container, Docker will execute the ls -l command as specified by the Dockerfile, revealing new_file1 was stored in the image. However we can still override ls -l by passing a command line argument: docker run -it your/duck:v3 [custom command] In the next tutorial, we will go into more detail in how these Dockerfiles are constructed for us.","title":"Creating Containers"},{"location":"docker/#layer-caching","text":"An important concept in Docker is the layers . In the previous section you may think that every time we build, we end up having to copy over the entire parent container. e.g. your/duck:v3 takes up another 2Gb of storage space! In actual fact, it (thankfully) does not, because under the hood the executable does not exist as one giant individible binary. It is in fact split into multiple independnet layers which can be shared in between images! Essentially each RUN line in your Dockerfile is compiled into a new layer placed upon the previous layers. This is helpful as if you try to build your container again, unless you change something, those previous layers are cached by Docker to be used instead of rebuilding the entire thing from scratch!","title":"Layer Caching"},{"location":"docker/#inspecting-a-container","text":"One of the downsides of containers is that manipulating files and inspecting the their state is not as simple. Previously, you could just browser through your own file system and check things. Now that a container has its own file system, its not as clear how you could check things have been set up correctly, or test run commands manually or similar. There are a number of different ways, but the simplest way is to exec into a running container. As an example, you can run starling-mavros again in one terminal. docker run uobflightlabstarling/starling-mavros In another terminal, identify the container ID or name by using docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 81b7dfb6c443 uobflightlabstarling/starling-mavros \"/ros_entrypoint.sh \u2026\" 3 seconds ago Up 2 seconds angry_yalow Note: The IDs have changed from the previous time we ran this container. Sometimes you want containers to persist, or do not want to delete them for testing and such. We can then use the ID of 81b7dfb6c443 or its name angry_yalow to exec into a container to run a command: docker exec -it angry_yalow [command] For example, in most cases it will be most useful to open up a bash terminal to inspect contents: docker exec -it angry_yalow bash root@81b7dfb6c443:/ros_ws# This opens up a terminal inside the container for you to navigate around and inspect things as you wish, in a similar manner to if you SSH'd into another machine. Note: Use the cat command to view the contents of files. Note: These containers have almost no tools to keep them slim. If you want to edit things, you will need to download a command line file editor. Run apt-get update then install an editor like nano with apt-get install nano .","title":"Inspecting a container"},{"location":"docker/#next-steps","text":"Hopefully you now have a decent understanding of what containerisation is and its purpose within Starling. You have also had a go at using the Docker command line tool to pull, run, build and inspect Starling containers going forward. With all that, we are now at a point where you can start creating your own containers to use!","title":"Next Steps"},{"location":"getting_started/","text":"Getting Started \u00b6 This first tutorial takes you through setting up your machine to be able to run Starling in order to follow the rest of the tutorial. Getting Started Preamble Prerequisits Git and Docker Murmuration - Starling Command Line Interface Cookiecutter Useful Programs Next Steps Preamble \u00b6 For this tutorial, it will be assumed that you have a functional understanding of the Linux, Mac or Windows interface. This includes use of the command line and terminal applications on linux or Mac, and powershell or Windows Subsystem for Linux (WSL) on windows. If you do not feel comfortable with either of these, it is recommended you have a read of this tutorial first: https://docs.starlinguas.dev/tutorials/introduction/#a-brief-introduction-to-linux . This tutorial covers some of the setup shown in this first tutorial in much more detail. Prerequisits \u00b6 Git and Docker \u00b6 You will need to install git to access the software and docker to run it. These are both supported on Windows, Mac and Linux. The Docker Desktop application should also be suitable. Linux users, please verify that the docker-compose tool is installed by running docker-compose --version . If it fails, install using sudo apt-get install docker-compose-plugin . see here . Windows users, it is highly recommended that you also install the Windows Subsystem for Linux (WSL) and use that as the backend for your Docker installations. see here for instructions It is also recommended that you sign up for a github account and a dockerhub account. Murmuration - Starling Command Line Interface \u00b6 You will need to download the Murmuration repository which contains a useful command line interface (cli). This can hopefully abstract away the need to remember all of the different commands. To install, go to your work directory and clone the repository using the command line or gui and run the following commands: git clone https://github.com/StarlingUAS/Murmuration.git # clones locally cd Murmuration In the bin directory of the repository, there is the core cli script named starling . starling includes a further installation script to help install further requirements. This installation script will need to be run using root. See the following guide on which arguments you should give. If running within Murmuration, swap starling for ./bin/starling . However for convenience, you can put starling onto your path. This can be done by adding export PATH=<Path to murmuration>/bin:$PATH into ~/.bashrc followed by source ~/.bashrc , or running the same command locally in the terminal. Then you can use the starling Then to finish the installation run: sudo starling install # or if you have not added starling to path and are in the Murmuration directory. sudo ./bin/starling install Cookiecutter \u00b6 The template generation uses the cookiecutter tool for generating custom projects from a template. To install, first install Python and then run the following: python3 -m pip install --user cookiecutter # or easy_install --user cookiecutter See cookiecutter installation for further details on different platforms. This will give you access to the cookiecutter command line interface. Useful Programs \u00b6 We highly recommend Visual Studio Code as our editing environment as it has a number of nice features, extensions and allows easy access to terminal windows. Once installed you can run vscode from any directory by running code <my directory> , e.g. code . . Next Steps \u00b6 This should give you all the tools to be able to run the tutorials. Before we dive into creating your own, let us first introduce all the core technologies which Starling makes use of, in order to give you enough background for you all to create your own controllers.","title":"1. Getting Started "},{"location":"getting_started/#getting-started","text":"This first tutorial takes you through setting up your machine to be able to run Starling in order to follow the rest of the tutorial. Getting Started Preamble Prerequisits Git and Docker Murmuration - Starling Command Line Interface Cookiecutter Useful Programs Next Steps","title":"Getting Started"},{"location":"getting_started/#preamble","text":"For this tutorial, it will be assumed that you have a functional understanding of the Linux, Mac or Windows interface. This includes use of the command line and terminal applications on linux or Mac, and powershell or Windows Subsystem for Linux (WSL) on windows. If you do not feel comfortable with either of these, it is recommended you have a read of this tutorial first: https://docs.starlinguas.dev/tutorials/introduction/#a-brief-introduction-to-linux . This tutorial covers some of the setup shown in this first tutorial in much more detail.","title":"Preamble"},{"location":"getting_started/#prerequisits","text":"","title":"Prerequisits"},{"location":"getting_started/#git-and-docker","text":"You will need to install git to access the software and docker to run it. These are both supported on Windows, Mac and Linux. The Docker Desktop application should also be suitable. Linux users, please verify that the docker-compose tool is installed by running docker-compose --version . If it fails, install using sudo apt-get install docker-compose-plugin . see here . Windows users, it is highly recommended that you also install the Windows Subsystem for Linux (WSL) and use that as the backend for your Docker installations. see here for instructions It is also recommended that you sign up for a github account and a dockerhub account.","title":"Git and Docker"},{"location":"getting_started/#murmuration-starling-command-line-interface","text":"You will need to download the Murmuration repository which contains a useful command line interface (cli). This can hopefully abstract away the need to remember all of the different commands. To install, go to your work directory and clone the repository using the command line or gui and run the following commands: git clone https://github.com/StarlingUAS/Murmuration.git # clones locally cd Murmuration In the bin directory of the repository, there is the core cli script named starling . starling includes a further installation script to help install further requirements. This installation script will need to be run using root. See the following guide on which arguments you should give. If running within Murmuration, swap starling for ./bin/starling . However for convenience, you can put starling onto your path. This can be done by adding export PATH=<Path to murmuration>/bin:$PATH into ~/.bashrc followed by source ~/.bashrc , or running the same command locally in the terminal. Then you can use the starling Then to finish the installation run: sudo starling install # or if you have not added starling to path and are in the Murmuration directory. sudo ./bin/starling install","title":"Murmuration - Starling Command Line Interface"},{"location":"getting_started/#cookiecutter","text":"The template generation uses the cookiecutter tool for generating custom projects from a template. To install, first install Python and then run the following: python3 -m pip install --user cookiecutter # or easy_install --user cookiecutter See cookiecutter installation for further details on different platforms. This will give you access to the cookiecutter command line interface.","title":"Cookiecutter"},{"location":"getting_started/#useful-programs","text":"We highly recommend Visual Studio Code as our editing environment as it has a number of nice features, extensions and allows easy access to terminal windows. Once installed you can run vscode from any directory by running code <my directory> , e.g. code . .","title":"Useful Programs"},{"location":"getting_started/#next-steps","text":"This should give you all the tools to be able to run the tutorials. Before we dive into creating your own, let us first introduce all the core technologies which Starling makes use of, in order to give you enough background for you all to create your own controllers.","title":"Next Steps"},{"location":"multiuav_kubernetes/","text":"Multi-UAV flight with Kubernetes for container deployment \u00b6","title":"8. Multi-UAV flight with Kubernetes for container deployment"},{"location":"multiuav_kubernetes/#multi-uav-flight-with-kubernetes-for-container-deployment","text":"","title":"Multi-UAV flight with Kubernetes for container deployment"},{"location":"next_steps/","text":"Wrapping up and next steps \u00b6","title":"12. Wrapping up and next steps"},{"location":"next_steps/#wrapping-up-and-next-steps","text":"","title":"Wrapping up and next steps"},{"location":"ros2_uav/","text":"An Introduction to ROS2 and UAV Control \u00b6 This tutorial gives a brief overview and background on UAV Control and ROS2. By the end you should have a brief understanding of how a UAV is controlled, how Starling treats a UAV and why and how we use ROS2 to communicate with a UAV An Introduction to ROS2 and UAV Control A Brief Introduction to UAV Control What is a UAV or a Drone How do you control a UAV The Autopilot MAVLink and Autopilot communication A Brief Introduction to ROS Why does ROS exist? What is ROS ROS concepts through an example ROS2 for Starling MAVLINK and ROS with MAVROS Next Steps A Brief Introduction to UAV Control \u00b6 What is a UAV or a Drone \u00b6 A drone or unmanned aerial vehicle (UAV) is an unmanned \"robotic\" vehicle that can be remotely or autonomously controlled. Drones are used for many consumer, industrial, government and military applications (opens new window). These include (non exhaustively): aerial photography/video, carrying cargo, racing, search and surveying etc. Different types of drones exist for use in air, ground, sea, and underwater. These are (more formally) referred to as Unmanned Aerial Vehicles (UAV), Unmanned Aerial Systems (UAS), Unmanned Ground Vehicles (UGV), Unmanned Surface Vehicles (USV), Unmanned Underwater Vehicles (UUV). The \"brain\" of the drone is called an autopilot . It consists of flight stack software running on vehicle controller (\"flight controller\") hardware. A multi-rotor is a specific type of UAV which uses two of more lift-generating rotors to fly. One of the most common will be the Quadrotor which has 4 motors in an 'X' pattern. These UAVs provide much simpler flight control than other types of aerial vehicle. This tutorial focuses on the flight of a simple quadrotor, but Starling can be used to operate many different types of robot. From this point on in this tutorial, 'drone' or 'UAV' will refer to a multi-rotor UAV unless otherwise stated. How do you control a UAV \u00b6 Modified from ardupilot docs A multicopter is a mechanically simple aerial vehicle whose motion is controlled by speeding or slowing multiple downward thrusting motor/propeller units. Combining different thrusts on different rotors allows the vehicle to move in free space with 6 degrees of freedom. However, manually controlling the individual thrusts of each motor in order to move the UAV is incredibly difficult, most would say its impossible even. This instability means that an on-board computer is mandatory for stable flight, as the on-board controller can perform the extreme high-rate control required to keep the drone in the air. In this \"Fly by wire\" paradigm, if the computer isnt working, you aren't flying. This dedicated on-board controller is referred to as the autopilot . This is seperate from a companion computer which is often used to direct the autopilot to achieve higher level mission goals. The autopilot combines data from small on-board MEMs gyroscopes and accelerometers (the same as those found in smart phones) to maintain an accurate estimate of its orientation and position. The quadcopter shown above is the simplest type of multicopter, with each motor/propeller spinning in the opposite direction from the two motors on either side of it (i.e. motors on opposite corners of the frame spin in the same direction). A quadcopter can control its roll and pitch rotation by speeding up two motors on one side and slowing down the other two. So for example if the quadcopter wanted to roll left it would speed up motors on the right side of the frame and slow down the two on the left. Similarly if it wants to rotate forward it speeds up the back two motors and slows down the front two. The copter can turn (aka \u201cyaw\u201d) left or right by speeding up two motors that are diagonally across from each other, and slowing down the other two. Horizontal motion is accomplished by temporarily speeding up/slowing down some motors so that the vehicle is leaning in the direction of desired travel and increasing the overall thrust of all motors so the vehicle shoots forward. Generally the more the vehicle leans, the faster it travels. Altitude is controlled by speeding up or slowing down all motors at the same time. In order to automatically map higher level motions to the thrust of the rotors, a cascading set of PID controllers is designed and provided by the autopilot. These then allow the remote control flight of the vehicle from a transmitter in your pilots hands, or via messages sent by the companion computer The Autopilot \u00b6 There is no universal controller design of converting from user inputs to motor thrust. In the same way, there are numerous other functionalities that an autopilot can cover. These can range from running control loops for gimbals, cameras and other actuation, to high level mission following and safety features. These functionalities are bundled into specific autopilot firmwares which each offer a slightly different set of features, as well as differing user interfaces each with their advantages and drawbacks. The two current most common autopilot firmware's in use in research settings are Ardupilot which offers the Arducopter firmware, and PX4 which offers Multicopter firmware. Both these firmwares are very extensive and cover numerous use cases. However, for our purposes we will only cover enabling autonomous flight through observing the mode of the autpilot. Both Ardupilot and PX4 use the concept of flight modes, where each mode operates a supports different levels or types of flight stabilisation and/or autonomous functions. Traditionally this is for pilots to change between different controller layouts for different applications. It's necessary to change to the correct mode for safe and controllable flight. The following table shows the most often used flight modes within Starling. Ardupilot Mode PX4 Mode Functionality stabilized manual Full manual control with RC sticks being sent directly to control roll, pitch, yaw and height PosHold position UAV uses onboard sensing to stay in place, RC sticks used to translate position loiter auto.hold Automatic mode where UAV stays in the same location until further instructions given. land auto.land Automatic mode which attempts to land the UAV Guided offboard Navigates to setpoints sent to it by ground control or companion computer Our controllers will all ask the autopilot to switch into guided or offboard mode in order to control from the companion computer. Often they have safety elements build in which mean that the autopilot must receive instructions at a certain rate (2Hz) otherwise the autopilot will switch to loiter or land. As mentioned before, the firmware provides a given cascading PID controller for converting high level commands to motor thrusts. As a controller developer, it is also useful to understand the differences between the Ardupilot and PX4 controllers and what real world impacts that has. Thankfully in most of Starling's targeted applications we only require position control which works fairly consistently between the two firmwares. In our own work, it has generally been noted that Ardupilot seems to be more suitable for outdoor flight, and PX4 for indoor flight. For this tutorial we will be developing an controller for indoor multi-vehicle flight and so we will assume the use of PX4. If interested in outdoor flight with Ardupilot, check out this tutorial which uses Starling with Ardupilot to simulate outdoor drone flight over a volcano. MAVLink and Autopilot communication \u00b6 Once in guided or offboard mode, the autopilot expects communications using the MAVLINK protocol . Traditionally this would have been used for a ground control station (GCS) to send commands to a UAV over a telemetry link. However, now it has also developed into a protocol for commanding the autopilot from an onboard companion computer over a USB or serial connection too. In Starling, both methods of communication between GCS or companion computer are supported. The MAVLink protocol is a set of preset commands which compatible firmwares understand and react to. However, it is often verbose and not-intuitive to develop applications with, as well as requiring a lot of prior knowledge about the state of the system. For example, it is neccesary to send a number of specific messages in order to receive individual data streams on vehicle status, location, global location and so on. These are often missed and cause lots of headaches for developers. Starling aims to streamline this through the use of the Robot Operating System so users no longer need to interact with MAVLink and the autopilot directly. A Brief Introduction to ROS \u00b6 This sections is adapted from this article ROS stands for the Robot Operating System, yet it isn't an actual operating system. It's a framework designed to expedite the development time of robot platforms. To understand what ROS is, we should understand why ROS exists in the first place. Why does ROS exist? \u00b6 In general, software developers avoid hardware like the plague. It's messy, doesn't have consistent behavior, and there's no ctrl-z in sight. Most beginner programmers think you have to have a deep knowledge of electronics and even mechanics to program robots. They think that the hardware and software are so tightly coupled, you have to know both in depth to build anything useful. Software developers became software developers for a reason, so they don't have to deal with hardware. For example, lets say you have to debug a faulty sensor. You first have to take out the sensor from the enclosure, test the sensor thoroughly with a multi meter and various test cases, document its behavior, then examine the hardware -level code to ensure that there were no bugs, and so on. That's a lot of interaction with the hardware that's not fun for someone who just wants to write some cool software. It's harder to attract good programmers if the programming is coupled deeply with hardware. This is where ROS comes into play. With ROS, you can completely abstract the hardware from software, and instead interact with an API that gives access to that data. You can forget about the hardware, and focus on developing the software that makes the robot do what you want. What is ROS \u00b6 ROS is essentially a framework that sits on top of an operating system which defines how particular ROS compatible programs communicate and share data with each other. Essentially ROS defines an interface between which compatible programs can communicate and interact with each other. Over the years that ROS has existed, many people have developed thousands of ROS compatible packages which can be used in a modular fashion. ROS concepts through an example \u00b6 To make it more concrete, imagine that on your drone you have a camera. There are also two processes which require, as inputs, that camera image. Say, a machine learning program, and a position estimation program. Traditionally, you would have to manually serialise (compress) and stream the image over a port which the other two programs could read from. But if the port changes or, say, the camera changes, lots of things have to be reconfigured. However, this sort of interaction can be made streamlined in ROS. Let us consider the programs we have as ROS nodes , i.e. a program which is responsible for one single modular purpose, with particular inputs or outputs: A camera image streaming node OUT: camera image A machine vision system for recognising objects IN: camera image OUT: list of recognised objects A simultaneous localisation and mapping system. IN: camera image OUT: vehicle position These outputs of a node define ROS topics , i.e. a single stream of one type of data. Each topic has a particular name which can be referred to. In our example, some of the topics might be: /drone/camera for the camera image /drone/recognised_objects for the machine vision system /drone/slam_position for the SLAM system Then, we see that there are two avenues of communication created from these node inputs and outputs. graph LR A[Camera] -->|out| node[drone/camera] node --in--> C[Machine Vision] node --in--> D[SLAM] style node fill:#f9f,stroke:#333,stroke-width:4px Now ROS follows a publisher/subscriber model of communication. What that means is that nodes publish data to topics as outputs. But that data is only sent across the network if a different nodes also subscribes to the same topic. So in our example we end up having A camera image streaming node OUT: publishing to /drone/camera A machine vision system for recognising objects IN: subscribed to /drone/camera OUT: publishing to /drone/recognised_objects A simultaneous localisation and mapping system. IN: subscribed to /drone/camera OUT: publishing to /drone/slam_position graph LR A[Camera] -->|out| node[drone/camera] node --in--> C[Vision] C -->|out| node1[drone/recognised_objects] node --in--> D[SLAM] D -->|out| node2[drone/slam_position] style node fill:#f9f,stroke:#333,stroke-width:4px style node1 fill:#f9f,stroke:#333,stroke-width:4px style node2 fill:#f9f,stroke:#333,stroke-width:4px Finally, the data that is sent is not just anything. The data or message is a specifically templated packet of data containing things specified for that paricular use case. In our example for /drone/slam_position topic, the message might be of type geometry_msgs/msg/Point.msg which is defined like so: # This contains the position of a point in free space float64 x float64 y float64 z In other words the message that the /drone/slam_position topic publishes must have a msg.x , msg.y and msg.z field, and the subscriber will only receivea message with those fields. There are a number of messages in the standard ROS library, but many libraries also define their own - as have we in some parts of Starling. This can be summarised in this diagram from the ROS tutorials demonstrates it very nicely: The bottom half of this shows how topics get sent from a publisher to a subscriber. Interestingly, if you put two topics together, you get some notion of two way communication. This is the basis of a service which can be seen in the top of the diagram. A service is made of a Request topic and a Response topic, but functions as a single communication type to the user. Similar to messages, a service has a defined request and response types (e.g. see std_srvs/srv/SetBool.srv ). A service request will often wait until a response is received before continuing. Note that everything happens asyncronously and in parallel, when a node subscribes or sends a requests, it doesn't know when the response will arrive. It only knows it will (hopefully) arrive at some point. When a packet is received the subscriber can then run a method - this method is usually known as a callback , but that will be covered in a later tutorial. Finally, each node is configured by a set of parameters which are broadcast to all other nodes. Parameters are often configuration values for particular methods in a node, and can sometimes be changed on startup (or dynamically through a service), to allow the node to provide adjustable functionality. For example the value of a timeout or frequency of a loop. So in summary, the key concepts and terminology are: Nodes Topics Publishers and Subscribers Messages Services Parameters ROS2 for Starling \u00b6 There are 2 versions of ROS: ROS1 and ROS2. ROS1, initially created in 2007 by Willow Garage, has become huge among the open source robotics community. However over the years they realised that there are a number of important features which are missing - and adding all of these would simply break ROS1. Also the most recent ROS1 distribution (ROS Noetic) is soon to reach the end of its supported life (EOL 2025) with no more ROS1 there after! (See this article for more details!) Therefore, to future proof the system, and to ensure all users get a well rounded experience that will hopefully translate to industry experience, Starling has been implemented in ROS2. Specifically, Starling uses the Foxy Fitzroy Long Term Support (LTS) distribution throughout. There are some interesting changes between ROS1 and ROS2, but the core elements described above remain identical. For those interested, ROS2 follows a much more decentralised paradigm, and does not require a central ROSnode as it uses the distributed DDS communication protocol for its internal communication. All nodes therefore broadcast their own topics allowing for easy decentralised discovery - perfect for multi-robot applications. Note: Main thing to be aware of is if you are debugging and searching for ROS questions on the internet, be aware that there are many existing questions for ROS1 which will no longer apply for ROS2. MAVLINK and ROS with MAVROS \u00b6 Coming back round to flying drones, we mentioned in that we wanted to use ROS to avoid having to manually communicate with the autopilot using MAVLINK. Starling uses the MAVROS ROS package to do exactly that. For the autpilot, it automatically sets up a connection and translates higher level ROS commands into MAVLINK commands. For controller developers, Mavros provides a known and consistent interface through a set of topics, services and parameters to interact with. These include high level actions such as requesting the vehicle's state, local position, gps position, as well as setting setpoints for the vehicle to visit. A couple of useful topics are in the following table: Name Topic Message Type Functionality State mavros/state mavros_msgs/msg/State Get's the current state and flight mode of the vehicle Local Position mavros/local_position/pose geometry_msgs/msg/PoseStamped Get the UAVs current coordinate position after sensor fusion GPS Position mavros/global_position/global sensor_msgs/msg/NavSatFix Get the UAVs current lat,long (if enabled) Position Setpoint mavros/setpoint_position/local geometry_msgs/msg/PoseStamped Send a target coordinate and orientation for the vehicle to fly to immediately Set Flight Mode mavros/set_mode mavros_msgs/srv/SetMode A service which sets the flight mode of the autopilot Set Data Stream Rate mavros/set_stream_rate mavros_msgs/srv/StreamRate A service which starts the data stream from the autopilot and sets its rate Sometimes, you may need to send raw MAVlink back to the Autopilot to enable some non-standard functionality. This can also be done through the MAVROS node too. As we are now utilising ROS, this allows us to make the most of the full ROS ecosystem in developing UAV applications. Next Steps \u00b6 Hopefully now you have a basic understanding of what a drone is and how they are controller, the function and purpose of an autopilot, as well as how ROS functions and can be used. If you want some early hands on experience with ROS before delving further into Starling, we highly recommend the offical ros2 tutorials . We have one more theory topic before you can start creating your own Starling projects, where we will be discussing how Starling uses and encapsulates ROS functionality.","title":"2. ROS2 and UAV Control"},{"location":"ros2_uav/#an-introduction-to-ros2-and-uav-control","text":"This tutorial gives a brief overview and background on UAV Control and ROS2. By the end you should have a brief understanding of how a UAV is controlled, how Starling treats a UAV and why and how we use ROS2 to communicate with a UAV An Introduction to ROS2 and UAV Control A Brief Introduction to UAV Control What is a UAV or a Drone How do you control a UAV The Autopilot MAVLink and Autopilot communication A Brief Introduction to ROS Why does ROS exist? What is ROS ROS concepts through an example ROS2 for Starling MAVLINK and ROS with MAVROS Next Steps","title":"An Introduction to ROS2 and UAV Control"},{"location":"ros2_uav/#a-brief-introduction-to-uav-control","text":"","title":"A Brief Introduction to UAV Control"},{"location":"ros2_uav/#what-is-a-uav-or-a-drone","text":"A drone or unmanned aerial vehicle (UAV) is an unmanned \"robotic\" vehicle that can be remotely or autonomously controlled. Drones are used for many consumer, industrial, government and military applications (opens new window). These include (non exhaustively): aerial photography/video, carrying cargo, racing, search and surveying etc. Different types of drones exist for use in air, ground, sea, and underwater. These are (more formally) referred to as Unmanned Aerial Vehicles (UAV), Unmanned Aerial Systems (UAS), Unmanned Ground Vehicles (UGV), Unmanned Surface Vehicles (USV), Unmanned Underwater Vehicles (UUV). The \"brain\" of the drone is called an autopilot . It consists of flight stack software running on vehicle controller (\"flight controller\") hardware. A multi-rotor is a specific type of UAV which uses two of more lift-generating rotors to fly. One of the most common will be the Quadrotor which has 4 motors in an 'X' pattern. These UAVs provide much simpler flight control than other types of aerial vehicle. This tutorial focuses on the flight of a simple quadrotor, but Starling can be used to operate many different types of robot. From this point on in this tutorial, 'drone' or 'UAV' will refer to a multi-rotor UAV unless otherwise stated.","title":"What is a UAV or a Drone"},{"location":"ros2_uav/#how-do-you-control-a-uav","text":"Modified from ardupilot docs A multicopter is a mechanically simple aerial vehicle whose motion is controlled by speeding or slowing multiple downward thrusting motor/propeller units. Combining different thrusts on different rotors allows the vehicle to move in free space with 6 degrees of freedom. However, manually controlling the individual thrusts of each motor in order to move the UAV is incredibly difficult, most would say its impossible even. This instability means that an on-board computer is mandatory for stable flight, as the on-board controller can perform the extreme high-rate control required to keep the drone in the air. In this \"Fly by wire\" paradigm, if the computer isnt working, you aren't flying. This dedicated on-board controller is referred to as the autopilot . This is seperate from a companion computer which is often used to direct the autopilot to achieve higher level mission goals. The autopilot combines data from small on-board MEMs gyroscopes and accelerometers (the same as those found in smart phones) to maintain an accurate estimate of its orientation and position. The quadcopter shown above is the simplest type of multicopter, with each motor/propeller spinning in the opposite direction from the two motors on either side of it (i.e. motors on opposite corners of the frame spin in the same direction). A quadcopter can control its roll and pitch rotation by speeding up two motors on one side and slowing down the other two. So for example if the quadcopter wanted to roll left it would speed up motors on the right side of the frame and slow down the two on the left. Similarly if it wants to rotate forward it speeds up the back two motors and slows down the front two. The copter can turn (aka \u201cyaw\u201d) left or right by speeding up two motors that are diagonally across from each other, and slowing down the other two. Horizontal motion is accomplished by temporarily speeding up/slowing down some motors so that the vehicle is leaning in the direction of desired travel and increasing the overall thrust of all motors so the vehicle shoots forward. Generally the more the vehicle leans, the faster it travels. Altitude is controlled by speeding up or slowing down all motors at the same time. In order to automatically map higher level motions to the thrust of the rotors, a cascading set of PID controllers is designed and provided by the autopilot. These then allow the remote control flight of the vehicle from a transmitter in your pilots hands, or via messages sent by the companion computer","title":"How do you control a UAV"},{"location":"ros2_uav/#the-autopilot","text":"There is no universal controller design of converting from user inputs to motor thrust. In the same way, there are numerous other functionalities that an autopilot can cover. These can range from running control loops for gimbals, cameras and other actuation, to high level mission following and safety features. These functionalities are bundled into specific autopilot firmwares which each offer a slightly different set of features, as well as differing user interfaces each with their advantages and drawbacks. The two current most common autopilot firmware's in use in research settings are Ardupilot which offers the Arducopter firmware, and PX4 which offers Multicopter firmware. Both these firmwares are very extensive and cover numerous use cases. However, for our purposes we will only cover enabling autonomous flight through observing the mode of the autpilot. Both Ardupilot and PX4 use the concept of flight modes, where each mode operates a supports different levels or types of flight stabilisation and/or autonomous functions. Traditionally this is for pilots to change between different controller layouts for different applications. It's necessary to change to the correct mode for safe and controllable flight. The following table shows the most often used flight modes within Starling. Ardupilot Mode PX4 Mode Functionality stabilized manual Full manual control with RC sticks being sent directly to control roll, pitch, yaw and height PosHold position UAV uses onboard sensing to stay in place, RC sticks used to translate position loiter auto.hold Automatic mode where UAV stays in the same location until further instructions given. land auto.land Automatic mode which attempts to land the UAV Guided offboard Navigates to setpoints sent to it by ground control or companion computer Our controllers will all ask the autopilot to switch into guided or offboard mode in order to control from the companion computer. Often they have safety elements build in which mean that the autopilot must receive instructions at a certain rate (2Hz) otherwise the autopilot will switch to loiter or land. As mentioned before, the firmware provides a given cascading PID controller for converting high level commands to motor thrusts. As a controller developer, it is also useful to understand the differences between the Ardupilot and PX4 controllers and what real world impacts that has. Thankfully in most of Starling's targeted applications we only require position control which works fairly consistently between the two firmwares. In our own work, it has generally been noted that Ardupilot seems to be more suitable for outdoor flight, and PX4 for indoor flight. For this tutorial we will be developing an controller for indoor multi-vehicle flight and so we will assume the use of PX4. If interested in outdoor flight with Ardupilot, check out this tutorial which uses Starling with Ardupilot to simulate outdoor drone flight over a volcano.","title":"The Autopilot"},{"location":"ros2_uav/#mavlink-and-autopilot-communication","text":"Once in guided or offboard mode, the autopilot expects communications using the MAVLINK protocol . Traditionally this would have been used for a ground control station (GCS) to send commands to a UAV over a telemetry link. However, now it has also developed into a protocol for commanding the autopilot from an onboard companion computer over a USB or serial connection too. In Starling, both methods of communication between GCS or companion computer are supported. The MAVLink protocol is a set of preset commands which compatible firmwares understand and react to. However, it is often verbose and not-intuitive to develop applications with, as well as requiring a lot of prior knowledge about the state of the system. For example, it is neccesary to send a number of specific messages in order to receive individual data streams on vehicle status, location, global location and so on. These are often missed and cause lots of headaches for developers. Starling aims to streamline this through the use of the Robot Operating System so users no longer need to interact with MAVLink and the autopilot directly.","title":"MAVLink and Autopilot communication"},{"location":"ros2_uav/#a-brief-introduction-to-ros","text":"This sections is adapted from this article ROS stands for the Robot Operating System, yet it isn't an actual operating system. It's a framework designed to expedite the development time of robot platforms. To understand what ROS is, we should understand why ROS exists in the first place.","title":"A Brief Introduction to ROS"},{"location":"ros2_uav/#why-does-ros-exist","text":"In general, software developers avoid hardware like the plague. It's messy, doesn't have consistent behavior, and there's no ctrl-z in sight. Most beginner programmers think you have to have a deep knowledge of electronics and even mechanics to program robots. They think that the hardware and software are so tightly coupled, you have to know both in depth to build anything useful. Software developers became software developers for a reason, so they don't have to deal with hardware. For example, lets say you have to debug a faulty sensor. You first have to take out the sensor from the enclosure, test the sensor thoroughly with a multi meter and various test cases, document its behavior, then examine the hardware -level code to ensure that there were no bugs, and so on. That's a lot of interaction with the hardware that's not fun for someone who just wants to write some cool software. It's harder to attract good programmers if the programming is coupled deeply with hardware. This is where ROS comes into play. With ROS, you can completely abstract the hardware from software, and instead interact with an API that gives access to that data. You can forget about the hardware, and focus on developing the software that makes the robot do what you want.","title":"Why does ROS exist?"},{"location":"ros2_uav/#what-is-ros","text":"ROS is essentially a framework that sits on top of an operating system which defines how particular ROS compatible programs communicate and share data with each other. Essentially ROS defines an interface between which compatible programs can communicate and interact with each other. Over the years that ROS has existed, many people have developed thousands of ROS compatible packages which can be used in a modular fashion.","title":"What is ROS"},{"location":"ros2_uav/#ros-concepts-through-an-example","text":"To make it more concrete, imagine that on your drone you have a camera. There are also two processes which require, as inputs, that camera image. Say, a machine learning program, and a position estimation program. Traditionally, you would have to manually serialise (compress) and stream the image over a port which the other two programs could read from. But if the port changes or, say, the camera changes, lots of things have to be reconfigured. However, this sort of interaction can be made streamlined in ROS. Let us consider the programs we have as ROS nodes , i.e. a program which is responsible for one single modular purpose, with particular inputs or outputs: A camera image streaming node OUT: camera image A machine vision system for recognising objects IN: camera image OUT: list of recognised objects A simultaneous localisation and mapping system. IN: camera image OUT: vehicle position These outputs of a node define ROS topics , i.e. a single stream of one type of data. Each topic has a particular name which can be referred to. In our example, some of the topics might be: /drone/camera for the camera image /drone/recognised_objects for the machine vision system /drone/slam_position for the SLAM system Then, we see that there are two avenues of communication created from these node inputs and outputs. graph LR A[Camera] -->|out| node[drone/camera] node --in--> C[Machine Vision] node --in--> D[SLAM] style node fill:#f9f,stroke:#333,stroke-width:4px Now ROS follows a publisher/subscriber model of communication. What that means is that nodes publish data to topics as outputs. But that data is only sent across the network if a different nodes also subscribes to the same topic. So in our example we end up having A camera image streaming node OUT: publishing to /drone/camera A machine vision system for recognising objects IN: subscribed to /drone/camera OUT: publishing to /drone/recognised_objects A simultaneous localisation and mapping system. IN: subscribed to /drone/camera OUT: publishing to /drone/slam_position graph LR A[Camera] -->|out| node[drone/camera] node --in--> C[Vision] C -->|out| node1[drone/recognised_objects] node --in--> D[SLAM] D -->|out| node2[drone/slam_position] style node fill:#f9f,stroke:#333,stroke-width:4px style node1 fill:#f9f,stroke:#333,stroke-width:4px style node2 fill:#f9f,stroke:#333,stroke-width:4px Finally, the data that is sent is not just anything. The data or message is a specifically templated packet of data containing things specified for that paricular use case. In our example for /drone/slam_position topic, the message might be of type geometry_msgs/msg/Point.msg which is defined like so: # This contains the position of a point in free space float64 x float64 y float64 z In other words the message that the /drone/slam_position topic publishes must have a msg.x , msg.y and msg.z field, and the subscriber will only receivea message with those fields. There are a number of messages in the standard ROS library, but many libraries also define their own - as have we in some parts of Starling. This can be summarised in this diagram from the ROS tutorials demonstrates it very nicely: The bottom half of this shows how topics get sent from a publisher to a subscriber. Interestingly, if you put two topics together, you get some notion of two way communication. This is the basis of a service which can be seen in the top of the diagram. A service is made of a Request topic and a Response topic, but functions as a single communication type to the user. Similar to messages, a service has a defined request and response types (e.g. see std_srvs/srv/SetBool.srv ). A service request will often wait until a response is received before continuing. Note that everything happens asyncronously and in parallel, when a node subscribes or sends a requests, it doesn't know when the response will arrive. It only knows it will (hopefully) arrive at some point. When a packet is received the subscriber can then run a method - this method is usually known as a callback , but that will be covered in a later tutorial. Finally, each node is configured by a set of parameters which are broadcast to all other nodes. Parameters are often configuration values for particular methods in a node, and can sometimes be changed on startup (or dynamically through a service), to allow the node to provide adjustable functionality. For example the value of a timeout or frequency of a loop. So in summary, the key concepts and terminology are: Nodes Topics Publishers and Subscribers Messages Services Parameters","title":"ROS concepts through an example"},{"location":"ros2_uav/#ros2-for-starling","text":"There are 2 versions of ROS: ROS1 and ROS2. ROS1, initially created in 2007 by Willow Garage, has become huge among the open source robotics community. However over the years they realised that there are a number of important features which are missing - and adding all of these would simply break ROS1. Also the most recent ROS1 distribution (ROS Noetic) is soon to reach the end of its supported life (EOL 2025) with no more ROS1 there after! (See this article for more details!) Therefore, to future proof the system, and to ensure all users get a well rounded experience that will hopefully translate to industry experience, Starling has been implemented in ROS2. Specifically, Starling uses the Foxy Fitzroy Long Term Support (LTS) distribution throughout. There are some interesting changes between ROS1 and ROS2, but the core elements described above remain identical. For those interested, ROS2 follows a much more decentralised paradigm, and does not require a central ROSnode as it uses the distributed DDS communication protocol for its internal communication. All nodes therefore broadcast their own topics allowing for easy decentralised discovery - perfect for multi-robot applications. Note: Main thing to be aware of is if you are debugging and searching for ROS questions on the internet, be aware that there are many existing questions for ROS1 which will no longer apply for ROS2.","title":"ROS2 for Starling"},{"location":"ros2_uav/#mavlink-and-ros-with-mavros","text":"Coming back round to flying drones, we mentioned in that we wanted to use ROS to avoid having to manually communicate with the autopilot using MAVLINK. Starling uses the MAVROS ROS package to do exactly that. For the autpilot, it automatically sets up a connection and translates higher level ROS commands into MAVLINK commands. For controller developers, Mavros provides a known and consistent interface through a set of topics, services and parameters to interact with. These include high level actions such as requesting the vehicle's state, local position, gps position, as well as setting setpoints for the vehicle to visit. A couple of useful topics are in the following table: Name Topic Message Type Functionality State mavros/state mavros_msgs/msg/State Get's the current state and flight mode of the vehicle Local Position mavros/local_position/pose geometry_msgs/msg/PoseStamped Get the UAVs current coordinate position after sensor fusion GPS Position mavros/global_position/global sensor_msgs/msg/NavSatFix Get the UAVs current lat,long (if enabled) Position Setpoint mavros/setpoint_position/local geometry_msgs/msg/PoseStamped Send a target coordinate and orientation for the vehicle to fly to immediately Set Flight Mode mavros/set_mode mavros_msgs/srv/SetMode A service which sets the flight mode of the autopilot Set Data Stream Rate mavros/set_stream_rate mavros_msgs/srv/StreamRate A service which starts the data stream from the autopilot and sets its rate Sometimes, you may need to send raw MAVlink back to the Autopilot to enable some non-standard functionality. This can also be done through the MAVROS node too. As we are now utilising ROS, this allows us to make the most of the full ROS ecosystem in developing UAV applications.","title":"MAVLINK and ROS with MAVROS"},{"location":"ros2_uav/#next-steps","text":"Hopefully now you have a basic understanding of what a drone is and how they are controller, the function and purpose of an autopilot, as well as how ROS functions and can be used. If you want some early hands on experience with ROS before delving further into Starling, we highly recommend the offical ros2 tutorials . We have one more theory topic before you can start creating your own Starling projects, where we will be discussing how Starling uses and encapsulates ROS functionality.","title":"Next Steps"},{"location":"simulation/","text":"Simulation and the Digital Double \u00b6 Simulation and the Digital Double UAV Simulation Gazebo BRL Digital Double Running the local simulator Next Steps UAV Simulation \u00b6 Gazebo \u00b6 BRL Digital Double \u00b6 Running the local simulator \u00b6 Next Steps \u00b6","title":"5. Simulation and the Digital Double"},{"location":"simulation/#simulation-and-the-digital-double","text":"Simulation and the Digital Double UAV Simulation Gazebo BRL Digital Double Running the local simulator Next Steps","title":"Simulation and the Digital Double"},{"location":"simulation/#uav-simulation","text":"","title":"UAV Simulation"},{"location":"simulation/#gazebo","text":"","title":"Gazebo"},{"location":"simulation/#brl-digital-double","text":"","title":"BRL Digital Double"},{"location":"simulation/#running-the-local-simulator","text":"","title":"Running the local simulator"},{"location":"simulation/#next-steps","text":"","title":"Next Steps"},{"location":"testing_with_docker_compose/","text":"Local Testing with Docker Compose \u00b6","title":"7. Local testing with Docker-Compose"},{"location":"testing_with_docker_compose/#local-testing-with-docker-compose","text":"","title":"Local Testing with Docker Compose"},{"location":"testing_with_kind/","text":"Local Integration testing with KinD Digital Double \u00b6","title":"9. Local Integration testing with KinD Digital Double"},{"location":"testing_with_kind/#local-integration-testing-with-kind-digital-double","text":"","title":"Local Integration testing with KinD Digital Double"}]}